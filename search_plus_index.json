{"./":{"url":"./","title":"Study notes","keywords":"","body":"Study notes © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"markdown-ru-men.html":{"url":"markdown-ru-men.html","title":"Markdown入门","keywords":"","body":"Markdown入门 三、引用 七、列表 **** 无序列表 无序列表就是列表不排序,支持- * + 3种前缀,可用于表示1级列表,2级列表,3级列表. 示例: - 无序列表1 * 无序列表2 + 无序列表3 列表嵌套 上一级和下一级列表之间空两个空格 ``即可表示列表嵌套. 示例: - 无序列表1 * 无序列表11 * 无序列表12 * 无序列表13 + 无序列表131 + 无序列表132 + 无序列表133 - 无序列表2 - 无序列表3 八、表格 |默认居左|文字居中|文字居右| |-|:-:|-:| |居左对齐1|居中对齐1|居右对齐1| |居左对齐2|居中对齐2|居右对齐2| |居左对齐3|居中对齐3|居右对齐3| 十、流程图 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"github-ji-gitbook-ru-men.html":{"url":"github-ji-gitbook-ru-men.html","title":"github及gitbook入门","summary":"写笔记，汇整成书籍形式方便查阅或分享，不希望造成额外的费用或时间成本，每次编辑书籍内容都能自动更新。解决方案：GitBook CLI + GitHub Pages + GitHub Actions","keywords":"","body":"github及gitbook入门 一、Github 创建个人主页 GitHub 为每一个用户分配了一个二级域名.github.io，用户为自己的二级域名创建主页很容易，只要在托管空间下创建一个名为.github.io的版本库，向其master分支提交网站静态页面即可，其中网站首页为index.html。访问网址：https://panxin30.github.io/ 创建项目主页 还可以为每个项目设置主页，项目主页也通过此二级域名进行访问。 访问地址：https://panxin30.github.io/book/ 为项目启用项目主页很简单，只需要在项目版本库中创建一个名为gh-pages的分支，并向其中添加静态网页即可。也就是说如果项目的Git版本库中包含了名为gh-pages分支的话，则表明该项目提供静态网页构成的主页，可以通过网址[.github.io/](http://.github.io/)访问到。\">http://[.github.io/](http://.github.io/)访问到。 创建gh-pages分支后，还需要在book这个仓库的settings中启用github pages 二、gitbook 1. 安装gitbook 参考：https://github.com/GitbookIO/gitbook/blob/master/docs/setup.md 2. 如果被墙，切换为淘宝镜像再安装 切换为使用国内速度较快的淘宝镜像。 npm config set registry=http://registry.npm.taobao.org -g 开始写书 方法一、直接在gitbook上新建space，然后点击integrations，整合github其中一个仓库，编辑gitbook会自动同步到github对应仓库。担心是gitbook被墙，在国内访问较慢。数据不会丢，因为用的github仓库存储。github上可以直接编辑 https://abu.gitbook.io/notes 方法二： 目标：在github新建一个仓库叫book，gitclone到本地，添加book.json，使用gitbook install book目录/ 安装插件，使用gitbook build book目录/构建静态资源，上传到panxin30.github.io或者book所在仓库的gh-pages分支（这就是github pages）。 缺点：不会自动更新，修改了书籍的源代码后需要再按照上面的操作来一次。前提是已经在本地安装了gitbook 方法三、使用github actions实现博客自动化部署 gitbook建立新书，关联到github仓库，给这个仓库添加actions，actions自动提交变更到gh-pages 以方法二为基础添加actions这一步 1. 设定GitHub Access Token 为了让GitHub Actions 能自动帮我们发布GitBook 成果到GitHub Pages，必须授权GitHub 操作我们的Repository。作法就是设定Access Token。 这里都是在GitHub 网页上操作，按照以下步骤即可： 2. 产生一个GitHub Personal Access Token： 点右上角帐号的头像->选择Settings->左边列表选择最底下的Developer settings->下个页面的左边列表选择Personal access tokens。 点击Generate new token按钮。 输入Token的描述，权限勾选repo:status和public_repo两个项目。 点最下面的Generate token按钮。 这时候页面上会显示一组Token，复制下来。注意！产生的Token内容只会在此时显示一次，之后无法再查到，如果忘记Token就只能重新操作产生一次。 3. 到Repository 将刚刚的Token 设定成Secret： 到想要自动发布的Repository ->选择Settings->左边列表选则Secrets->点New secret按钮。 「Name」栏位填GH_ACCESS_TOKEN，「Value」栏位贴上刚刚复制的Token。 点Add secret按钮，设定就完成了。 4. GitHub Actions Workflow 万事俱备，只剩下设定GitHub Actions，让它能自动帮我们制书和发布到GitHub Pages。 回到资料夹，新增一个.github/workflows/build.yml档案： $ mkdir -p .github/workflows $ vi .github/workflows/build.yml 这里完全照抄即可，只需要把USER_NAME和USER_EMAIL设定更换成你的Git User Name和Email： name: Build my gitbook and deploy to gh-pages on: workflow_dispatch: push: branches: - master jobs: build: name: Build Gitbook runs-on: ubuntu-latest steps: # Check out the repo first - name: Checkout code uses: actions/checkout@v2 # Run this action to publish gitbook - name: Publish uses: tuliren/publish-gitbook@v1.0.0 with: # specify either github_token or personal_token github_token: 23e77fcdfda67b264737527285c2049f268c9f2a # personal_token: ${{ secrets.PERSONAL_TOKEN }} 上面是一个GitHub Actions的设定档，称为一个「workflow」。里面用到官方的checkout action，这几乎是每个workflow的起手式。使用https://github.com/marketplace/actions/publish-gitbook 选择的一个gitbook相关的别人做好的镜像,负责将markdown档制成GitBook静态网站，并自动将网站档案commit到gh-pagesbranch。 5. 将Workflow 档推上GitHub，触发自动发布到GitHub Pages 将刚刚新增的workflow 档进行commit 和push： $ git add .github/workflows/build.yml $ git commit -m \"add workflow file\" $ git push 回到GitHub Repository 页面，点「Actions」tab，会看到有一个workflow 任务被自动触发执行中： 等到执行完毕变成绿勾勾，会看到自动建立了gh-pagesbranch并commit GitBook静态网站的档案： 测试有没有自动更新 三、gitbook 插件 gitbook插件可以解决一些网站不太方便的地方，如侧边栏导航不能收缩，自带搜索不支持中文等。 插件安装、使用方法： 1、 在book.json的plugins参数中添加插件名。2、终端使用gitbook install来安装插件，或使用NPM命令来单独安装：npm install gitbook-plugin-插件名。3、重新打包就能看见效果。 注意：1、插件一定先要在book.json文件里面plugins中才能生效，如果只是安装了插件，而没配置的话是不会生效的。2、gitbook命令安装慢，而且是全部插件都安装一遍，如果只安装一个插件的话建议使用NPM命令安装。 还有很多可用插件，具体如下： 信息框(flexible-alerts) 阅读统计（pageview-count） 侧边栏宽度可调节（splitter） 页脚版权（page-copyright） 打赏功能（donate） 分享当前页面（sharing-plus） 修改标题栏图标（custom-favicon） 复选框（todo） 显示图片名称（image-captions） 目录折叠（toggle-chapters） 分章节展示（multipart） 插入 Logo（insert-logo） Google 分析（ga） 返回顶部（back-to-top-button） 代码添加行号和复制按钮（code） 高级搜索，支持中文（search-pro） 添加 Github 图标（github） 左侧目录可折叠 2.2.1 chapter-fold 支持多层目录，点击导航栏的标题名就可以实现折叠扩展。在book.json的plugins参数中添加插件名： { \"plugins\": [\"chapter-fold\"] } 然后使用npm install gitbook-plugin-chapter-fold命令安装插件。注意：要想目录折叠，SUMMARY.md目录应该如下： * [项目介绍](README.md) * [tcp说明](doc/http/tcp/tcp说明.md) * [udp说明](doc/http/tcp/udp/udp说明.md) * [html](doc/html/readme.md) * [HTML5-特性说明](doc/html/HTML5-特性说明.md) 如下写法会产生bug，导致CSS是收缩的，不能展开，效果如上面的动图： * CSS * [说明](doc/css/readme.md) 2.2.2 expandable-chapters 这个插件也是左侧目录折叠的插件，不同的是可以解决chapter-fold插件的bug，怎么写都会折叠目录在book.json的plugins参数中添加插件名： { \"plugins\": [ \"expandable-chapters\" ] } 安装命令：npm install gitbook-plugin-expandable-chapters注意：这个插件也有问题，就是如下写法的，需要点击箭头才能展开收缩菜单： * [tcp说明](doc/http/tcp/tcp说明.md) * [udp说明](doc/http/tcp/udp/udp说明.md) 解决的办法是和chapter-fold插件一起用，互补一下各自的问题就完美解决了： \"plugins\": [ \"expandable-chapters\", \"chapter-fold\", ] 2.5 回到顶部按钮 在book.json的plugins参数中添加插件名和配置信息： { \"plugins\": [ \"back-to-top-button\" ], } 使用npm install gitbook-plugin-back-to-top-button命令安装插件。 3.2 右上角添加github图标 在book.json的plugins参数中添加插件名和配置信息： { \"plugins\": [ \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/zhangjikai\" } } } 然后使用npm install gitbook-plugin-github命令安装插件。注意：如果使用npm命令安装后报错GitBook doesn't satisfy the requirements of this plugin: >=4.0.0-alpha.0.请使用gitbook install来安装.或者npm uninstall gitbook-plugin-github卸载后，使用npm i gitbook-plugin-github@2.0.0安装，然后查看是否还报错。 3.3 edit-link在线编辑文件 book.json中插件名和配置信息： { \"plugins\": [\"edit-link\"], \"pluginsConfig\": { \"edit-link\": { \"base\": \"//github.com/yulilong/book/edit/master\", \"label\": \"编辑此页面\" } } } 使用npm i gitbook-plugin-edit-link命令安装插件。 点击编辑按钮，即可跳转到github仓库在线编辑这个文件。 3.6 prism代码块颜色插件(测试没有通过) 插件地址：https://github.com/gaearon/gi...此插件需要禁用gitbook自带的highlight插件。book.json中插件名和配置信息： { \"plugins\": [\"prism\", \"-highlight\"], \"pluginsConfig\": { \"prism\": { \"css\": [ \"prismjs/themes/prism-okaidia.css\" ] } } } 使用npm install gitbook-plugin-prism命令安装插件。 更多的颜色参考：https://github.com/gaearon/gi... 注意：代码块的语言标注比如JS,CSS,如果标注一个插件不认识的语言，在运行打包命令gitbook build .这个插件会报错，提示不认识这个语言，这里需要注意一下。 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/":{"url":"book/","title":"Book","keywords":"","body":"Book © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/":{"url":"book/notes/","title":"notes","keywords":"","body":"notes © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/shell/":{"url":"book/notes/shell/","title":"shell","keywords":"","body":"shell © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/shell/ru-he-cai-neng-xue-hao-shell-bian-cheng-zhi-lao-niao-jing-yan-tan.html":{"url":"book/notes/shell/ru-he-cai-neng-xue-hao-shell-bian-cheng-zhi-lao-niao-jing-yan-tan.html","title":"如何才能学好Shell编程之“老鸟”经验谈","keywords":"","body":"如何才能学好Shell编程之“老鸟”经验谈 学好Shell编程的核心：多练→多思考→再练→再思考，坚持如此循环即可！ 从老男孩IT教育毕业的一名学生曾在工作多年后返校分享了一篇“如何学好Shell编程”的讲稿，经过老男孩的整理后和读者分享如下。 （1）掌握Shell脚本基本语法的方法 最简单有效的方法就是将语法敲n+1遍。为什么不是n遍呢？因为这里的n指的是你刚开始为掌握语法而练习的那些天（21天法则），而1则是指在确定掌握语法后每天都要写一写、想一想，至少是要看一看，保持一个与Shell脚本接触的热度。 （2）掌握Shell脚本的各种常见语法 要掌握各类条件表达式、if多种判断、for循环的不同用法、While多种读文件的循环等，这样做不是为了什么都学会，而是为了能够看懂别人写的代码。掌握常见的各种语法，也就是要经常写，而且要持续写一段时间（让动作定型，在大脑和肌肉里都打上深刻烙印），各种语法都要用。 （3）形成自己的脚本开发风格 当掌握了各种常见的语法之后，就要选定一种适合自己的语法，形成自己的开发风格，例如：if语句的语法就只用一种，条件表达式的语法只用一种，函数的写法也只用一种，有些语法需要根据场景去选择，除非你是像师傅（老男孩）一样要教学育人。否则，没有必要什么语法都掌握。在解决问题的前提下，掌握一种语法，然后将其用精、用透就是最好的，切记横向贪多，要多纵深学习。 （4）从简单做起，简单判断，简单循环 初学者一定要从简单做起，最小化代码学习，简单判断，简单循环，简单案例练习，所有的大程序都是由多个小程序组成的，因此，一开始没必要写多大的程序，免得给自己带来过多的挫败感，形成编程恐惧症。可先通过小的程序培养兴趣及成就感，到碰到大的程序时，即使遇到困难也能坚持下去了。 （5）多模仿，多放下参考资料练习，多思考 多找一些脚本例子来仔细分析一下，或者是系统自带的，或者是别人写的（本书就包含大量例子），不要只看，看着会并不是真的会。当你闭上眼睛的时候，还能完整地回忆起来，甚至还能完整口述或手写出来才是真的会。 （6）学会分析问题，逐渐形成编程思维 在编写程序或脚本时，先将需求理解透，对大的需求进行分解，逐步形成小的程序或模块，然后再开发，或者先分析最终需求的基础实现，最后逐步扩展批量实现。例如师傅（老男孩）在编写批量关闭不需要自启动服务的脚本时，就采用了这种分析方法，思路如下： 1）掌握关闭一个服务的命令，即“chkconf?ig服务名off”。 2）批量处理时，会有多个服务名，那么就要用到多条以上的命令。 3）仔细分析以上命令，会发现需要处理的所有命令中，只有“服务名”不同，其他地方都一样，那么自然就会想到用循环语句来处理。 如果是你，能想到这些吗？若是想到了，则表示你已经形成了初级的编程思维了，恭喜你。 如果你能够通过分析将一个大的需求细分为各个小的单元，然后利用函数、判断、循环、命令等实现每一个小的单元，那么最后把所有程序组合起来就是一个大的脚本程序了。 如果达到了上述的水平，你就算会编程了，对于领导提出的需求，就能够进行合理的分解，只要在机器上多进行调试，相信一定能写出来。 （7）编程变量名字要规范，采用驼峰语法表示 oldboyAgeName用的就是驼峰表示法。记住，在学习的初期，不要去看大的脚本，要从小问题和小的方面着手，当你觉得小的判断、循环等在你的脑子里瞬间就能出来时，再开始去看和写大的脚本，进行深入练习。 师傅（老男孩）常说，新手初期最好的学习方法就是多敲代码，并针对问题进行分解练习，多敲代码就是让自己养成一个编程习惯，使肌肉、视觉和思维形成记忆，分解问题实际上就是掌握软件的设计和实现思想。 对于最高的编程境界，我个人的理解是：能把大问题进行完整的分析、分解且高效解决。 完整性：就是指预先考虑到各种可能性，将问题分解后，合理模块化并实现。 高效率：例如，在求“1+2+3...+100”的和时，考虑使用算法“（1+100）×100/2”，而不是逐个去加。 （8）不要拿来主义，特别是新手 好多网友看书或学习视频时，喜欢要文档、要代码，其实，这是学习的最大误区。 有了文档和代码，你会变得非常懒惰，心里面会觉得已经学会了，而实际上并没有学会。因此无论是看书还是学习视频，都要自己完成学习笔记及代码的书写，这本身就是最重要的学习过程，在学习上要肯于花时间和精力，而不是投机取巧。如果你至今都没有学好Linux运维，那么可以想一想是不是也犯了这个错误？ 做事情若有多种选择，就会比较轻松，没有选择就会比较痛苦。 提交解决方案、面试提问、笔试等都是如此 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/shell/shi-zhan/":{"url":"book/notes/shell/shi-zhan/","title":"实战","keywords":"","body":"实战 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/shell/shi-zhan/scripts/":{"url":"book/notes/shell/shi-zhan/scripts/","title":"scripts","keywords":"","body":"scripts © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/shell/shi-zhan/scripts/qian-yi-jiao-ben.html":{"url":"book/notes/shell/shi-zhan/scripts/qian-yi-jiao-ben.html","title":"迁移脚本","keywords":"","body":"迁移脚本 #!/bin/bash PEXIT (){ echo $1 exit 9 } #导出中间库生成的数据 dump_newdb (){ id=$1 echo -e \"正在导出转化后的数据，请确认ID: $id 是否正确,10秒后继续,Ctrl+C 取消.\" sleep 10 mysqldump -uroot -h120.76.46.55 -pnHH29kEA7 brokerwork_t\"$id\" > 1.sql mysqldump -uroot -h120.76.46.55 -pnHH29kEA7 brokerwork_t\"$id\"_mt4_1 > 2.sql sed -e 's/DEFINER[ ]*=[ ]*[^*]*\\*/\\*/ ' 1.sql > brokerwork_t\"$id\".sql sed -e 's/DEFINER[ ]*=[ ]*[^*]*\\*/\\*/ ' 2.sql > brokerwork_t\"$id\"_mt4_1.sql mysqldump -uroot -h120.76.46.55 -pnHH29kEA7 --complete-insert --no-create-info --skip-add-locks message_transfer_t\"$id\" >message_transfer_t\"$id\".sql mongodump -h120.76.46.55:27017 -dtransfer\"$id\" -umsc -pabc123 -o /data/scripts/ # 如果有实时返佣 # mongodump -h120.76.46.55:27017 -drcr_t\"$id\" -uadmin --authenticationDatabase=admin -pWAer8R59G6 -o /root/ } #第二步 #将转化后的数据导入到测试环境. import_newdb_dev (){ id=$1 echo -e \"正在将转化后的数据导入开发环境，请确认ID: $id 是否正确,10秒后继续,Ctrl+C 取消.\" sleep 10 #导入到测试环境1,2不用再操作 mysql -uroot -h120.76.46.55 -pnHH29kEA7 bw_message qa_bw_message_$backup_date.sql mysqldump -ubwqa -hrm-j6c40s6glhqsd26cc.mysql.rds.aliyuncs.com -pGycHWb@qx9Ld --set-gtid-purged=OFF brokerwork_t$id > qa_bw_t$id_$backup_date.sql #import data to bw4.0 QA echo -e \"开始将mysql数据导入到qa mysql\\n\" sleep 3 mysql -ubwqa -hrm-j6c40s6glhqsd26cc.mysql.rds.aliyuncs.com -pGycHWb@qx9Ld -e \"drop database brokerwork_t$id;\" || PEXIT \"drop database brokerwork_t$id 失败.\" mysql -ubwqa -hrm-j6c40s6glhqsd26cc.mysql.rds.aliyuncs.com -pGycHWb@qx9Ld -e \"create database brokerwork_t$id;\" || PEXIT \"create database brokerwork_t$id 失败.\" mysql -ubwqa -hrm-j6c40s6glhqsd26cc.mysql.rds.aliyuncs.com -pGycHWb@qx9Ld brokerwork_t\"$id\" create_mongodb.js mongo 10.25.154.114:27017/brokerwork -ubrokerwork -p4wUgjFA create_mongodb.js # mongo 10.26.149.225:27017/brokerwork -ubrokerwork -p4wUgjFA create_mongodb.js # mongo 10.26.149.213:27017/brokerwork -ubrokerwork -p4wUgjFA create_mongodb.js #测试上面的语句 mongorestore -h10.25.154.114:27017 -dbrokerwork -ubrokerwork -p4wUgjFA transfer\"$id\" # mongorestore -h10.26.149.225:27017 -dbrokerwork -ubrokerwork -p4wUgjFA transfer\"$id\" # mongorestore -h10.26.149.213:27017 -dbrokerwork -ubrokerwork -p4wUgjFA transfer\"$id\" # 如果有实时返佣 # mongorestore -h10.26.60.3:27017 -drcr_t\"id\" -uroot -pleanwork123 --authenticationDatabase=admin --drop /root/rcr_t\"$id\" echo -e \"导入数据到qa环境完成\\n\" sleep 3 } #第四步 #导入到生产环境 #备份bw_message再导入这份数据(带上日期) #这里的id如000128 #db.getCollection('t_tasks_item').remove({'tenantId' : 'T000029'}); import_newdb_prod (){ id=$1 echo -e \"正在将转化后的数据导入开发环境，请确认ID: $id 是否正确,10秒后继续,Ctrl+C 取消.\" sleep 10 backup_date=`date \"+%Y-%m-%d-%H-%M\"` #/usr/bin/mysqldump -h127.0.0.1 -uroot -pGyc@HWb.qx9Ld --set-gtid-purged=OFF --all-databases > ali-hk-bw-db2.sql mysqldump -uroot -h10.28.184.253 -pGyc@HWb.qx9Ld --set-gtid-purged=OFF bw_message > prod_bw_message_$backup_date.sql mysqldump -uroot -h10.28.184.253 -pGyc@HWb.qx9Ld --set-gtid-purged=OFF brokerwork_t\"$id\" > brokerwork_t\"$id\"_$backup_date.sql echo -e \"即将删除数据库:brokerwork_t$id,请核对是否正确!!!;10秒后继续，Ctrl+C 取消. \\n\" sleep 10 mysql -uroot -h10.28.184.253 -pGyc@HWb.qx9Ld -e \"drop database brokerwork_t$id;\" || PEXIT \"drop database brokerwork_t$id 失败.\" mysql -uroot -h10.28.184.253 -pGyc@HWb.qx9Ld -e \"create database brokerwork_t$id;\" || PEXIT \"create database brokerwork_t$id 失败.\" mysql -uroot -h10.28.184.253 -pGyc@HWb.qx9Ld brokerwork_t\"$id\" create_mongodb.js mongo 10.28.185.68:27017/brokerwork -ubrokerwork -po6RJzAF1LELzutEv create_mongodb.js mongorestore -h10.28.185.68:27017 -dbrokerwork -ubrokerwork -po6RJzAF1LELzutEv transfer\"$id\" #mongorestore -h10.47.43.22:27017 -dbrokerwork -ubrokerwork -po6RJzAF1LELzutEv transfer\"$id\" #mongorestore -h10.47.36.173:27017 -dbrokerwork -ubrokerwork -po6RJzAF1LELzutEv transfer\"$id\" # 如果有返佣 # mongorestore -h10.47.43.22:27017 -drcr_t\"$id\" -uadmin -p'Jp@2Cny&XIun' --authenticationDatabase=admin rcr_t\"$id\" # mongorestore -h10.28.185.68:27017 -drcr_t\"$id\" -uadmin -p'Jp@2Cny&XIun' --authenticationDatabase=admin rcr_t\"$id\" echo -e \"导入数据到生产环境完成\\n\" sleep 3 } #id如000128 echo -e \"导出转化后的数据\\n\" sleep 3 #dump_newdb 000136 || PEXIT \"导出数据失败，请查看日志。\" echo -e \"导入新数据到dev环境\\n\" sleep 3 #import_newdb_dev id || PEXIT \"导入数据到dev环境失败。\" echo -e \"导入新数据到qa环境\\n\" sleep 3 #import_newdb_qa 000136 || PEXIT \"导入数据到qa环境失败.\" echo -e \"导入新数据到prod环境\\n\" sleep 3 import_newdb_prod 000136 || PEXIT \"导入数据到prod环境失败。\" exit 0 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/shell/shi-zhan/shell-jiao-ben-tiao-shi.html":{"url":"book/notes/shell/shi-zhan/shell-jiao-ben-tiao-shi.html","title":"shell脚本调试","keywords":"","body":"shell脚本调试 Shell脚本调试就是发现引发脚本错误的原因以及在脚本源代码中定位发生错误的行，常用的手段包括分析输出的错误信息，通过在脚本中加入调试语句，输出调试信息来辅助诊断错误，利用调试工具等 set -eux Shell脚本的错误可分为两类： 1.语法错误（syntax error），脚本无法执行到底。2.Shell脚本能够执行完毕，但是并不是按照我们所期望的方式运行，即存在逻辑错误 trap命令 tee命令 用于调试管道，tee -a 追加结果到debug.txt localIP=`cat /etc/sysconfig/network-scripts/ifcfg-eth0 | tee debug.txt | grep 'IPADDR' | tee -a debug.txt | cut -d= -f2 | tee -a debug.txt` echo \"The local IP is: $localIP\" © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/shell/shi-zhan/for-he-while-du-hang-de-qu-bie.html":{"url":"book/notes/shell/shi-zhan/for-he-while-du-hang-de-qu-bie.html","title":"for和while读行的区别","keywords":"","body":"for和while读行的区别 $ cat file aaaa bbbb cccc dddd $ cat file | while read line; do echo $line; done aaaa bbbb cccc dddd $ for line in $( © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/shell/shi-zhan/yi-ge-wen-jian-qu-2-ge-can-shu.html":{"url":"book/notes/shell/shi-zhan/yi-ge-wen-jian-qu-2-ge-can-shu.html","title":"一个文件取2个参数","keywords":"","body":"一个文件取2个参数 root@cn-office-crm-qa-all-k8s01:~# cat 1.txt registry-hk-tools.lwork.com/bw-account:master-31 registry-hk-tools.lwork.com/bw-copy-trade:master-3 对k8s集群中服务的镜像升级同时需要服务名字和镜像地址链 root@cn-office-crm-qa-all-k8s01:~# cat 2.sh #!/bin/bash for i in $(cat 1.txt) do k=$(echo $i | awk -F ':' '{print $1}' | awk -F '/' '{print $2}') kubectl set image deploy $k $k=$i -n crm-prod sleep 120 done © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/openstack/":{"url":"book/notes/openstack/","title":"Openstack","keywords":"","body":"Openstack © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/openstack/openstack-ji-chu/":{"url":"book/notes/openstack/openstack-ji-chu/","title":"openstack基础","keywords":"","body":"openstack基础 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/openstack/openstack-ji-chu/wang-luo-xu-ni-hua-ji-shu-ji-chu.html":{"url":"book/notes/openstack/openstack-ji-chu/wang-luo-xu-ni-hua-ji-shu-ji-chu.html","title":"网络虚拟化技术基础","keywords":"","body":"网络虚拟化技术基础 网络虚拟化： 桥接 隔离 路由 NAT 一旦虚拟机部署到了某个物理机上，cpu和内存就只能使用该物理 管理节点两张网卡 内网网络网卡或者多一个可以访问互联网的网卡 物理机节点两张网卡 一个用于实现管理操作，一个用于所有能建立虚拟机的物理机彼此通信 网络节点3张网卡，一个内部管理用，一个用于连接互联网，一个跟各物理机通信 管理节点跟虚拟化不在同一个概念中 VLAN间路由: 路由器: 访问链接：router为每个vlan提供一个接口 汇聚链接：router只向交换机提供一个接口 三层交换机： 三层交换机既有二层功能又有三层功能。首先在2层能够在各个接口之间实现报文交换的功能， 在上面额外提供一个软件实现路由 # 容器级的虚拟化，就是利用linux内核提供的资源隔离功能来实现的。 虚拟化技术： linux内核： namespace：名称空间，完成特定类型资源的隔离 cgroups：控制组，可以在已经隔离出来的的名称空间中，按比例把资源分配到名称空间中去 假设一台服务器有16核，分成4个分支ABCD（A-8C,B-4C,C-2C,D-2C）A这个分支可以分成 3个分支(A1-3C,A2-3C,A3-2C)。那么一个进程，可以绑定到根上，这16核，它想用多少用多 少。也可以绑定到A分支上，最多能用8核。也可以绑定到A1分支上，最多能用3核。也可以绑定 到B分支上，最多能用4核。 网络虚拟化技术 复杂的虚拟化网络： netns OpenVSwitch openvswitch:基于C语言研发，特性： 支持802.1q,trunk,access 支持NIC绑定， NetFlow,sFlow QoS配置及策略 GRE，Vxlan OpenFlow 基于linux实现高性能转发 openvswitch的组成部分： ovs-vswitchd: ovs daemon,实现数据报文交换功能，和linux内核兼容模块一同实现了基于流的 交换技术 ovsdb-server:轻量级的数据库服务，主要保存了整个OVS的配置信息 ovs-vsctl: 用于获取或更改ovs-vswitchd的配置信息，修改操作会保存到ovsdb-server © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/openstack/openstack-ji-chu/openstack-ji-chu.html":{"url":"book/notes/openstack/openstack-ji-chu/openstack-ji-chu.html","title":"openstack基础","keywords":"","body":"openstack基础 IaaS(openstack),PaaS(docker),SaaS Object Storage: 代码名Swift:分布式存储，基于RESTful的API实现非结构化数据对象的存储及检索。 Block Storage: 代码名Cinder: 为运行实例而提供的持久性块存储。 image service:代码名字Glance: 当nova创建一个虚拟机实例，需要下载磁盘映像的时候，会先找glance，glance会告诉你到哪里去下载。所以glance是作为swift前端，存储和检索虚拟机磁盘镜像。 Identity: 代码名Key stone: 为Openstack中所有服务提供认证和授权服务以及端点目录 新建并启动一个实例的流程： 通过dashboard/CLI发起创建实例 -->先到keystone请求认证，认证通过则访问nova-api(能收到用户请求的调用接口,监听在某个套接字上, tcp连接的端点叫套接字（socket）,根据RFC 793的定义,端口号拼接到IP地址即构成了套接字 ) -->nova-api收到请求后，再查询keystone这个帐号有没有相应权限，有则下一步nova-api先查询novaDB(存放此前创建过的实例的各种结果实例名,虚拟核心数,内存大小等。大概新建实例的规格也存放在这?)-->novaDB把待建实例的规格发送给nova-api-->nova-api把这个信息生成一个特定的请求交给nova-cumpute，但是nova-api和nova-compute之间的交流是异步的，因此nova-api把这个特定的请求丢给Queue(队列)-->nova-scheduler在队列中读取到这个新建请求，根据此新建请求和调度策略选择一个计算节点-->nova-scheduler更新选择信息到nova DB中，确认保存后-->nova-scheduler将此调度结果丢到Queue(队列)-->被选中的compute节点从Queue队列中读取到调度结果，在本地运行实例(为了避免给novaDB造成太大压力,nova-compute把新建实例的运行等相关信息仍到Queue队列中)-->nova-conductor负责从Queue队列中取出与数据库更新相关的信息-->novaDB存储信息-->返回存储信息给nova-conductor-->仍给Queue队列-->nova-compute获取自己更新实例信息存储到数据库的结果，下一步，这个实例需要运行除了需要CPU,内存之外的其他资源,磁盘镜像，网络服务，磁盘服务等 -->nova-compute向glance-api发起请求，检索存在glace-registry中自己需要的磁盘镜像文件相关信息，并到image store下载相关镜像，在此之前glance-api会先去keystone验证这个帐号有没有相关权限 -->nova-compute连接neutron-server(创建虚拟网络，网桥，把接口关联到网桥上,创建虚拟路由器，在虚拟路由上生成对应的规则以实现路由转发或地址转换) -->neutron-server是个很繁忙的服务，因此收到请求后不会直接构建网络，而是仍到Queue队列中异步与其他相关neutron-plugins协作，根据查询neutronDB来完成对对应实例的虚拟网络的创建，其中有一部分需要在真正运行了此实例的compute节点上的neutron agent来实现(网桥等)-->因此把需求扔到Queue队列中，待建实例所在的计算节点的neutron agent收到请求，给待建实例创建好网桥，网卡等，把创建虚拟网络的相关信息保存到neutronDB，然后通知neutron server通知nova-compute。在此之前neutron server会先到keystone验证权限。 -->nova-compute向cinder-api发起请求块存储，cinder-api先向keystone认证通过后-->cinder-volume分析请求，查询cinderDB，确定没有问题后扔到Queue队列中，由cinder负责具体生成卷及分配卷-->保存结果到cinderDB-->反馈给cinder-api-->反馈给nova-compute，然后开始启动实例。 三节点openstack架构 controller node,network node,compute node controller node: mysql+rabbitmq,keystone, © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/openstack/openstack-an-zhuang/":{"url":"book/notes/openstack/openstack-an-zhuang/","title":"openstack安装","keywords":"","body":"openstack安装 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/notes/openstack/openstack-an-zhuang/environment.html":{"url":"book/notes/openstack/openstack-an-zhuang/environment.html","title":"Environment","summary":"参考：https://docs.openstack.org/install-guide/","keywords":"","body":"Environment © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/ubuntu/":{"url":"book/ubuntu/","title":"Ubuntu","keywords":"","body":"Ubuntu ubuntu18.04文档: https://help.ubuntu.com/18.04/serverguide/index.html?_ga=2.27270844.101266492.1614050993-2066796206.1614050993 ubuntu latest文档: https://ubuntu.com/server/docs © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/ubuntu/ubuntu-networking/":{"url":"book/ubuntu/ubuntu-networking/","title":"ubuntu networking","summary":"ubuntu 18.04","keywords":"","body":"ubuntu networking © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/ubuntu/ubuntu-networking/network-configuration.html":{"url":"book/ubuntu/ubuntu-networking/network-configuration.html","title":"Network Configuration","summary":"引用：https://help.ubuntu.com/18.04/serverguide/network-configuration.html","keywords":"","body":"Network Configuration 一、Ethernet Interfaces Identify Ethernet Interfaces识别以太网接口 To quickly identify all available Ethernet interfaces ip a Another application that can help identify all network interfaces available to your system is the lshw command. This command provides greater details around the hardware capabilities of specific adapters. In the example below, lshw shows a single Ethernet interface with the logical name of eth0 along with bus information, driver details and all supported capabilities. sudo lshw -class network *-network description: Ethernet interface product: MT26448 [ConnectX EN 10GigE, PCIe 2.0 5GT/s] vendor: Mellanox Technologies physical id: 0 bus info: pci@0004:01:00.0 logical name: eth4 version: b0 serial: e4:1d:2d:67:83:56 slot: U78CB.001.WZS09KB-P1-C6-T1 size: 10Gbit/s capacity: 10Gbit/s width: 64 bits clock: 33MHz capabilities: pm vpd msix pciexpress bus_master cap_list ethernet physical fibre 10000bt-fd configuration: autonegotiation=off broadcast=yes driver=mlx4_en driverversion=4.0-0 duplex=full firmware=2.9.1326 ip=192.168.1.1 latency=0 link=yes multicast=yes port=fibre speed=10Gbit/s resources: iomemory:24000-23fff irq:481 memory:3fe200000000-3fe2000fffff memory:240000000000-240007ffffff Ethernet Interface Logical Names Interface logical names can also be configured via a netplan configuration. If you would like control which interface receives a particular logical name use the match and set-name keys. The match key is used to find an adapter based on some criteria like MAC address, driver, etc. Then the set-name key can be used to change the device to the desired logial name. network: version: 2 renderer: networkd ethernets: eth_lan0: dhcp4: true match: macaddress: 00:11:22:33:44:55 set-name: eth_lan0 二、IP Addressing 三、Name Resolution 四、Bridging 五、Resources $ give me super-powers © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/network-foundation.html":{"url":"book/network-foundation.html","title":"Network foundation","keywords":"","body":"Network foundation © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/za/":{"url":"book/za/","title":"za","keywords":"","body":"za © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/za/yi-jian-an-zhuang-gitlab-hou-de-bei-fen-he-hui-fu.html":{"url":"book/za/yi-jian-an-zhuang-gitlab-hou-de-bei-fen-he-hui-fu.html","title":"一键安装gitlab后的备份和恢复","keywords":"","body":"一键安装gitlab后的备份和恢复 https://docs.gitlab.com/ce/README.html Omnibus packages rpm -qa | grep gitlab-ce sudo apt-cache policy gitlab-ce | grep Installed ***** /etc/gitlab/gitlab.rb 包含的nginx，redis，数据库等，要改配置生效的话，都从gitlab.rb里面改 gitlab-ctl tail #查看是否有错误 gitlab-ctl reconfigure 加载配置文件 gitlab 为安装一体化，内置nginx/redis/postgresql等 gitlab 主程序目录： /var/opt/gitlab/ 主配置文件： /var/opt/gitlab/gitlab-shell/config.yml gitlab 认证文件： /var/opt/gitlab/.ssh/authorized\\_keys 日志文件： /var/log/gitlab/gitlab-shell/gitlab-shell.log nginx 配置文件 ： /var/opt/gitlab/nginx/conf/nginx.conf /var/opt/gitlab/nginx/conf/gitlab-http.conf 3、所有与gitlab相关服务统一通过gitlab来启动 gitlab: 启动、关闭、重启方式： gitlab-ctl start \\| stop \\| restart 4、备份，还原和迁移 Gitlab创建备份 ## gitlab-rake gitlab:backup:create 使用以上命令会在/var/opt/gitlab/backups目录下创建一个名称类似为1393513186_gitlab_backup.tar的压缩包, 这个压缩包就是Gitlab整个的完整部分, 其中开头的1393513186是备份创建的日期。 Gitlab恢复 ## 停止相关数据连接服务 gitlab-ctl stop unicorn gitlab-ctl stop sidekiq ## 从1393513186编号备份中恢复 gitlab-rake gitlab:backup:restore BACKUP=1393513186 ## 启动Gitlab sudo gitlab-ctl start 迁移如同备份与恢复的步骤一样, 只需要将老服务器/var/opt/gitlab/backups目录下的备份文件拷贝到新服务器上的/var/opt/gitlab/backups即可(如果你没修改过默认备份目录的话)。但是需要注意的是新服务器上的Gitlab的版本必须与创建备份时的Gitlab版本号相同. 比如新服务器安装的是最新的8.5版本的Gitlab, 那么迁移之前, 最好将老服务器的Gitlab 升级为8.5再进行备份。 自动备份 通过crontab使用备份命令实现自动备份: sudo su - crontab -e 例如加入以下, 实现每天凌晨2点进行一次自动备份: 0 2 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/za/hui-fueli-yun-wu-li-bei-fen.html":{"url":"book/za/hui-fueli-yun-wu-li-bei-fen.html","title":"恢复阿里云物理备份","keywords":"","body":"恢复阿里云物理备份 引用：https://help.aliyun.com/knowledge\\_detail/41817.html # 恢复mysql，dump其中一部分数据 ### mysql数据库较大，下载解压4小时左右 1.在备份机root@ali-hk-lw-databackup上有每天的备份,已经安装了mysql5.7.28和mongo3.4.19,Percona XtraBackup2.4 2.下载备份 `wget -c '' -O .tar.gz` 3.解压 `tar -izxvf .tar.gz -C /data/restore/mysql` 4.执行如下命令，恢复解压好的备份文件。 `innobackupex --defaults-file=/data/restore/mysql/backup-my.cnf --apply-log /data/restore/mysql` 因为文件大，所以连开始都慢，不能直接停止，否则一个log文件会消失，就不能再成功执行了。只有重新解压缩包 5.自建数据库不支持下面的参数，注销**backup-my.cnf**中相关参数 ``` #innodb_log_checksum_algorithm #innodb_fast_checksum #innodb_log_block_size #innodb_doublewrite_file #rds_encrypt_data #innodb_encrypt_algorithm #redo_log_version #master_key_id #server_uuid ``` 6.修改文件所属 `chown -R mysql:mysql /data/restore/mysql` 7.执行如下命令，启动MySQL进程。 `mysqld --defaults-file=/data/restore/mysql/backup-my.cnf --user=mysql --datadir=/data/restore/mysql &` ### 结果报错 ## Can't change dir to '/xxx' (Errcode: 13)，Permission denied，真是奇怪，所属已经改了的 ## 最后处理办法，**将restore也修改所属为mysql** 8.**导出需要的数据，再恢复到生产环境**。 或者用命令启动确认没有问题后，再修改/etc/my.cnf中数据库目录，直接使用这个配置启动 # mongodb 恢复 ### **目前7天前的备份存储在oss中，需要先解冻再用 wget -c -O 下载，再恢复** **最好用docker run一个mongo，想要什么版本就什么版本** 使用mongo3.4.19 引用https://help.aliyun.com/document\\_detail/58329.html?spm=a2c6r.11610030.0.0.63b64231DrgJiF 1.下载阿里云mongodb物理备份 `wget -c '' -O .tar.gz` 2.解压到指定目录 `tar zxf saas.owsc.20191126.tar.gz -C mongo/` 3.以单节点模式恢复MongoDB物理备份的数据 引用WiredTiger 存储引擎的配置文件，修改mongodb所在目录 4.启动mongo `/usr/bin/mongod -f /etc/mongod.conf` 5.等待启动完成后，可通过服务器的 mongo shell 登录 MongoDB 数据库。帐号密码就是线上数据库帐号密码 `mongo 127.0.0.1:27017/owsc -uowsc -pDS3x8mHP` 6，dump需要的数据，再恢复到生产。 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/za/yu-ming-zheng-shu-shen-qing-he-geng-huan.html":{"url":"book/za/yu-ming-zheng-shu-shen-qing-he-geng-huan.html","title":"域名证书申请和更换","keywords":"","body":"域名证书申请和更换 一级域名com,edu,cn,net,org 二级域名lwork.com lwork.cn ### 泛域名证书的使用,**只支持2级域名** ***.lwork.com只支持bac.lwork.com,abc.lwork.com不支持abc.bac.lwork.com** **1.更换证书** 域名证书到期，到godaddy对应域名下载新证书，因为使用的是nginx 所以下载类别选其他 证书文件 dfe616168a014563.crt dfe616168a014563.pem gd_bundle-g2-g1.crt 生成新的crt `cat dfe616168a014563.crt gd_bundle-g2-g1.crt > lwork.crt` 使用该crt替换老的crt **2.更换证书** 起因是最近需要更换一台服务器上的SSL证书，客服是直接把crt包（含pem和2个crt，**godaddy下载的apache版本**包）、一个key.txt和一个csr.txt发给我，这次不大一样，但是文件应该没问题，我nginx的配置使用的是key+crt形式 正常合并crt `cat 4babe335689330b5.crt gd_bundle-g2-g1.crt > private_cloud2.crt` key使用客服发过来的key.txt nginx -t 报错 (SSL: error:0906D06C:PEM routines:PEM_read_bio:no start line:Expecting: ANY PRIVATE KEY) 网上找到一种思路 ``` file xxx.key #查看编码格式 iconv -l #查看系统支持的格式 vi xxx.key :set fileencoding=ASCII #保存退出，确认一遍格式 ``` nginx -t成功 [https://stackoverflow.com/questions/43729770/nginx-godaddy-ssl/43730023\\]\\(https://stackoverflow.com/questions/43729770/nginx-godaddy-ssl/43730023\\) **3. 新域名申请证书** [https://sg.godaddy.com/zh/help/nginx-csr-3601\\]\\(https://sg.godaddy.com/zh/help/nginx-csr-3601\\) 通过 SSH 连接至您的服务器（[了解详细信息](https://sg.godaddy.com/zh/help/ssh-4943\\)）。 运行以下命令： openssl req -new -newkey rsa:2048 -nodes -keyout\\*您的域名\\*.key -out\\*您的域名\\*.csr 用您保护的域名替换\\*\\`您的域名\\`\\*。 例如，如果您的域名是 coolexample.com，您可以键入\\`coolexample.key\\`和\\`coolexample.csr\\`。 输入申请的信息： \\| 字段 \\| 输入的内容 \\| \\| --- \\| --- \\| \\| \\*\\*通用名称\\*\\* \\| 您想要保护的完全合格的域名，或 URL。 如果您申请通配证书，在您想要通配的通用名称左侧添加一个星号 \\(\\\\*\\)，例如\\*\\\\*.coolexample.com\\*。 \\| \\| \\*\\*组织\\*\\* \\| 您企业的法定注册名称。 如果以个人身份注册，则输入证书申请者的姓名。 \\| \\| \\*\\*组织单位\\*\\* \\| 如适用，请输入营业名称 \\(Doing Business As, DBA\\)。 \\| \\| \\*\\*城市或地区\\*\\* \\| 您的组织注册/所在的城市名称。 不要缩写。 \\| \\| \\*\\*州或省\\*\\* \\| 您的组织所在的州或省的名称。 不要缩写。 \\| \\| \\*\\*国家\\*\\* \\| 您的组织合法注册所在国家的\\[国家代码\\]\\(http://www.iso.org/iso/home/standards/country\\_codes/iso-3166-1\\_decoding\\_table.htm\\)（按照国际标准化组织 \\(ISO\\) 的双字母格式）。 \\| \\| \\*\\*密码\\*\\* \\| （\\*可选\\*）： SSL 的密码。 如果您将此字段留空，则 SSL 无密码，会让您暴露于其他风险中。 \\| 在文本编辑器中打开 CSR，然后复制所有文本。 将完整的 CSR 粘贴到您账户的 SSL 申请区域。 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/za/fu-wu-qi-shang-pai-cha-wen-ti-de-tou-5-fen-zhong.html":{"url":"book/za/fu-wu-qi-shang-pai-cha-wen-ti-de-tou-5-fen-zhong.html","title":"服务器上排查问题得头5分钟","keywords":"","body":"服务器上排查问题得头5分钟 一、尽可能搞清楚问题的前因后果 不要一下子就扎到服务器前面，你需要先搞明白对这台服务器有多少已知的情况，还有故障的具体情况。不然你很可能就是在无的放矢。 必须搞清楚的问题有： • 故障的表现是什么？无响应？报错？ • 故障是什么时候发现的？ • 故障是否可重现？ • 有没有出现的规律（比如每小时出现一次） • 最后一次对整个平台进行更新的内容是什么（代码、服务器等）？ • 故障影响的特定用户群是什么样的(已登录的, 退出的, 某个地域的…)? • 基础架构（物理的、逻辑的）的文档是否能找到? • 是否有监控平台可用? （比如Munin、Zabbix、 Nagios、 New Relic… 什么都可以） • 是否有日志可以查看?. （比如Loggly、Airbrake、 Graylog…） 最后两个是最方便的信息来源，不过别抱太大希望，基本上它们都不会有。只能再继续摸索了。 二、有谁在? $ w $ last 用这两个命令看看都有谁在线，有哪些用户访问过。这不是什么关键步骤，不过最好别在其他用户正干活的时候来调试系统。有道是一山不容二虎嘛。（ne cook in the kitchen is enough.） 三、之前发生了什么? $ history 查看一下之前服务器上执行过的命令。看一下总是没错的，加上前面看的谁登录过的信息，应该有点用。另外作为admin要注意，不要利用自己的权限去侵犯别人的隐私哦。 到这里先提醒一下，等会你可能会需要更新 HISTTIMEFORMAT 环境变量来显示这些命令被执行的时间。对要不然光看到一堆不知道啥时候执行的命令，同样会令人抓狂的。 四、现在在运行的进程是啥? $ pstree -a $ ps aux 这都是查看现有进程的。 ps aux 的结果比较杂乱， pstree -a 的结果比较简单明了，可以看到正在运行的进程及相关用户。 五、监听的网络服务 $ netstat -ntlp $ netstat -nulp $ netstat -nxlp 我一般都分开运行这三个命令，不想一下子看到列出一大堆所有的服务。netstat -nalp倒也可以。不过我绝不会用 numeric 选项 （鄙人一点浅薄的看法：IP 地址看起来更方便）。 找到所有正在运行的服务，检查它们是否应该运行。查看各个监听端口。在netstat显示的服务列表中的PID 和 ps aux 进程列表中的是一样的。 如果服务器上有好几个Java或者Erlang什么的进程在同时运行，能够按PID分别找到每个进程就很重要了。 通常我们建议每台服务器上运行的服务少一点，必要时可以增加服务器。如果你看到一台服务器上有三四十个监听端口开着，那还是做个记录，回头有空的时候清理一下，重新组织一下服务器。 六、CPU 和内存 $ free -m $ uptime $ top $ htop 注意以下问题: • 还有空余的内存吗? 服务器是否正在内存和硬盘之间进行swap? • 还有剩余的CPU吗? 服务器是几核的? 是否有某些CPU核负载过多了? • 服务器最大的负载来自什么地方? 平均负载是多少? 七、硬件 有很多服务器还是裸机状态，可以看一下： • 找到RAID 卡 (是否带BBU备用电池?)、 CPU、空余的内存插槽。根据这些情况可以大致了解硬件问题的来源和性能改进的办法。 • 网卡是否设置好? 是否正运行在半双工状态? 速度是10MBps? 有没有 TX/RX 报错? 八、IO 性能 $ iostat -kx 2 $ vmstat 2 10 $ mpstat 2 10 $ dstat --top-io --top-bio 这些命令对于调试后端性能非常有用。 • 检查磁盘使用量：服务器硬盘是否已满? • 是否开启了swap交换模式 (si/so)? • CPU被谁占用：系统进程? 用户进程? 虚拟机? • dstat 是我的最爱。用它可以看到谁在进行 IO： 是不是MySQL吃掉了所有的系统资源? 还是你的PHP进程? 九、挂载点 和 文件系统 $ mount $ cat /etc/fstab $ vgs $ pvs $ lvs $ df -h $ lsof +D / /* beware not to kill your box */ • 一共挂载了多少文件系统? • 有没有某个服务专用的文件系统? (比如MySQL?) • 文件系统的挂载选项是什么： noatime? default? 有没有文件系统被重新挂载为只读模式了？ • 磁盘空间是否还有剩余? • 是否有大文件被删除但没有清空? • 如果磁盘空间有问题，你是否还有空间来扩展一个分区？ 十、内核、中断和网络 $ sysctl -a | grep ... $ cat /proc/interrupts $ cat /proc/net/ip_conntrack /* may take some time on busy servers */ $ netstat $ ss -s • 你的中断请求是否是均衡地分配给CPU处理，还是会有某个CPU的核因为大量的网络中断请求或者RAID请求而过载了？ • SWAP交换的设置是什么？对于工作站来说swappinness 设为 60 就很好, 不过对于服务器就太糟了：你最好永远不要让服务器做SWAP交换，不然对磁盘的读写会锁死SWAP进程。 • conntrack_max 是否设的足够大，能应付你服务器的流量? • 在不同状态下(TIME_WAIT, …)TCP连接时间的设置是怎样的？ • 如果要显示所有存在的连接，netstat 会比较慢， 你可以先用 ss 看一下总体情况。 你还可以看一下 Linux TCP tuning 了解网络性能调优的一些要点。 十一、系统日志和内核消息 $ dmesg $ less /var/log/messages $ less /var/log/secure $ less /var/log/auth • 查看错误和警告消息，比如看看是不是很多关于连接数过多导致？ • 看看是否有硬件错误或文件系统错误? • 分析是否能将这些错误事件和前面发现的疑点进行时间上的比对。 十二、定时任务 $ ls /etc/cron* + cat $ for user in $(cat /etc/passwd | cut -f1 -d:); do crontab -l -u $user; done • 是否有某个定时任务运行过于频繁? • 是否有些用户提交了隐藏的定时任务? • 在出现故障的时候，是否正好有某个备份任务在执行？ 十三、应用系统日志 这里边可分析的东西就多了, 不过恐怕你作为运维人员是没功夫去仔细研究它的。关注那些明显的问题，比如在一个典型的LAMP（Linux+Apache+MySQL+Perl）应用环境里: • Apache & Nginx; 查找访问和错误日志, 直接找 5xx 错误, 再看看是否有 limit_zone错误。 • MySQL; 在mysql.log找错误消息，看看有没有结构损坏的表， 是否有innodb修复进程在运行，是否有disk/index/query 问题. • PHP-FPM; 如果设定了 php-slow 日志, 直接找错误信息 (php, mysql, memcache, …)，如果没设定，赶紧设定。 • Varnish; 在varnishlog 和 varnishstat 里, 检查 hit/miss比. 看看配置信息里是否遗漏了什么规则，使最终用户可以直接攻击你的后端？ • HA-Proxy; 后端的状况如何？健康状况检查是否成功？是前端还是后端的队列大小达到最大值了？ 结论 经过这5分钟之后，你应该对如下情况比较清楚了： • 在服务器上运行的都是些啥？ • 这个故障看起来是和 IO/硬件/网络 或者 系统配置 (有问题的代码、系统内核调优, …)相关。 • 这个故障是否有你熟悉的一些特征？比如对数据库索引使用不当，或者太多的apache后台进程。 你甚至有可能找到真正的故障源头。就算还没有找到，搞清楚了上面这些情况之后，你现在也具备了深挖下去的条件。继续努力吧！ © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/windows/":{"url":"book/windows/","title":"Windows","keywords":"","body":"Windows © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/windows/winserver-guan-bi-shi-jian-gen-zong-cheng-xu.html":{"url":"book/windows/winserver-guan-bi-shi-jian-gen-zong-cheng-xu.html","title":"winserver关闭事件跟踪程序","keywords":"","body":"winserver关闭事件跟踪程序 winserver重启后出现事件跟踪界面，导致自启动的服务没有启动 gpedit.msc 依次展开计算机配置→管理模板→系统，在右边的窗口中找到显示“关闭事件跟踪程序” 启用在登陆时不显式\"管理你的服务器\" 服务器管理器登录不自动启动 打开服务器管理器-->点击管理-->服务器管理器属性-->选择在登陆时不自动启动 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/windows/windows-chang-yong-ming-ling.html":{"url":"book/windows/windows-chang-yong-ming-ling.html","title":"windows常用命令","keywords":"","body":"windows常用命令 services.msc 服务 control.exe 控制面板 gpedit.msc 本地组策略 regedit.exe 注册表 systeminfo eventvwr.msc 日志 `netstat -ano | findstr 端口号` # **更改系统区域设置** * Windows 8.1/Windows 10/Windows Server 2012/Windows Server 2012 R2/Windows 2016/Windows Server 2019：单击屏幕左下角的Windows徽标，单击k控制面板，然后单击区域。在区域对话框中，单击管理选项卡，然后单击非 Unicode 程序的语言下的**更改系统区域设置。** © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/windows/win10-qi-ye-ltsc-ban-ji-huo.html":{"url":"book/windows/win10-qi-ye-ltsc-ban-ji-huo.html","title":"win10企业LTSC版激活","keywords":"","body":"win10企业LTSC版激活 引用:https://www.win10zjb.com/win10jihuo/8430.html Windows 10 LTSC 2019 Windows 10 企业版 LTSC 2019：M7XTQ-FN8P6-TTKYV-9D4CC-J462D Windows 10 企业版 N LTSC 2019：2NFX-8DJQP-P6BBQ-THF9C-7CG2H 1.管理员启动cmd 2.在命令符号符窗口输入以下内容 slmgr/ipk M7XTQ-FN8P6-TTKYV-9D4CC-J462D slmgr/skms kms.03k.org slmgr/ato © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/windows/debug-tools.html":{"url":"book/windows/debug-tools.html","title":"debug-tools","keywords":"","body":"debug-tools https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/debugger-download-tools © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/untitled/":{"url":"book/untitled/","title":"Untitled","keywords":"","body":"Untitled © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/untitled/a.html":{"url":"book/untitled/a.html","title":"A","keywords":"","body":"A architecture [ˈärkəˌtek(t)SHər] 体系结构 架构 automated [ˈôdəˌmādəd] 自动化的 auto-negotiation 自动协商。自动协商是一项功能，它允许交换机，路由器，服务器或其他设备上的端口与链路另一端的设备进行通信，以确定最佳的双工模式和连接速度。两边都需要运行自动协商才行。 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/untitled/c.html":{"url":"book/untitled/c.html","title":"C","keywords":"","body":"C capability [ˌkāpəˈbilədē] This command provides greater details around the hardware capabilities of specific adapters. © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/untitled/d.html":{"url":"book/untitled/d.html","title":"D","keywords":"","body":"D distribution [ˌdistrəˈbyo͞oSH(ə)n] 分配 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/untitled/m.html":{"url":"book/untitled/m.html","title":"M","keywords":"","body":"M manually [ˈmanyə(wə)lē] 手动地 multiple [ˈməltəpəl] 多 in multiple scenarios在多种情况下。 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/untitled/i.html":{"url":"book/untitled/i.html","title":"I","keywords":"","body":"I Identify Ethernet Interfaces识别以太网接口 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/untitled/p.html":{"url":"book/untitled/p.html","title":"P","keywords":"","body":"P program [ˈprōˌɡram] 程序 the process of 的过程 The following section describes the process of configuring your systems IP address and default gateway needed for communicating on a local area network and the Internet. © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "},"book/untitled/s.html":{"url":"book/untitled/s.html","title":"S","keywords":"","body":"S scenario [səˈnerēˌō]设想 in multiple scenarios在多种情况下。 © panxin30 all right reserved，powered by Gitbook文件修订时间: 2021-02-24 10:58:19 "}}